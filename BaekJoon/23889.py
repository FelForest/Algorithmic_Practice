'''
문제
경기북과학고등학교에 숨겨져 있는 알프스 산맥에는 많은 마을이 있다. 알프스 산맥에 살던 도현이는 충격적인 사실을 듣게 되었다. 바로, 내일 큰 돌들이 굴러가 마을을 덮칠 것이라는 사실이었다.

집은 부서지지 않겠지만, 마을의 아이들이 쌓아놓은 모래성이 부서질 것이므로 매우 심각한 일이었다. 돌은 모두 왼쪽에서 오른쪽으로 계속 굴러가며, 돌은 굴러가기 시작하는 마을의 모래성부터 부수기 시작한다.

다행히도 도현이에게는 굴러오는 돌을 막을 수 있는 벽이 있다. 하지만, 돌의 개수가 도현이가 가지고 있는 벽의 개수 이상인 것이 문제이다. 고민하는 도현이를 도와 어디에 벽을 설치해야 가장 많은 모래성을 지킬 수 있을지 알아보자.

벽은 설치된 마을부터 돌이 굴러가지 못하도록 막는다. 따라서 벽이 설치된 마을부터는 돌이 모래성을 부수지 못한다.

입력
첫 번째 줄에는 마을의 개수 $N$, 가지고 있는 벽의 개수 $M$, 돌의 개수 $K$가 주어진다.

두 번째 줄에는 $i$번째 마을의 모래성의 개수 $x_i $가 공백으로 구분되어 주어진다.

세 번째 줄에는 돌이 굴러가기 시작하는 마을의 위치들이 주어진다. 마을의 위치는 맨 왼쪽에 위치한 마을이 1번째 마을, 가장 오른쪽이 $N$번째 마을이다. 돌의 위치는 중복되지 않으며, 오름차순으로 주어진다.

출력
 $M$번째 줄에 걸쳐 가장 많은 모래성을 지키기 위해 벽을 설치해야 할 마을의 위치를 오름차순으로 출력한다. 가장 많은 모래성을 지킬 수 있는 경우가 두 가지 이상 존재할 경우, 사전순으로 가장 빠른 답을 출력한다.

제한
 $1 ≤ N ≤ 10^5$ 
 $1 ≤ M ≤ K ≤ N$ 
모든 $1 ≤ i ≤ N$에 대해 $1 ≤ x_i ≤ 10^4$ 
서브태스크
번호	배점	제한
1	9	
 $M = K$ 

2	16	
 $N ≤ 100$, $K ≤ 25$ 

3	75	
추가적인 제한이 없다.

예제 입력 1 
7 2 3
2 5 3 7 1 6 8
1 4 5
예제 출력 1 
1
5
벽을 1번째 마을과 5번째 마을에 두게 되면 4번째 마을의 모래성만 부서지게 되며, 4번째 마을의 모래성 개수인 7개가 부서지는 모래성의 최소 개수이다.
'''
import sys
#from heapq import heappop,heappush
#sys.setrecursionlimit(10000000)
input = sys.stdin.readline

n,m,k = map(int,input().split())
castles = list(map(int,input().split()))
p = list(map(int,input().split()))

broken = []

for i in range(k-1):
  broken.append([p[i],sum(castles[p[i]-1:p[i+1]-1])])

broken.append([p[-1],sum(castles[p[-1]-1::])])
broken.sort(reverse = True, key = lambda x : x[1])
#print(broken)
guard = []
for i in range(m):
  guard.append(broken[i][0])

guard.sort()
print(*guard,sep="\n")
